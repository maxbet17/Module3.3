"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadFile = exports.uploadToIpfs = void 0;
const tslib_1 = require("tslib");
const fs_1 = (0, tslib_1.__importDefault)(require("fs"));
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const common_1 = require("@subql/common");
const axios_1 = (0, tslib_1.__importDefault)(require("axios"));
const form_data_1 = (0, tslib_1.__importDefault)(require("form-data"));
const ipfs_http_client_1 = require("ipfs-http-client");
const constants_1 = require("../constants");
async function uploadToIpfs(projectDir, authToken, ipfsEndpoint) {
    const reader = await common_1.ReaderFactory.create(projectDir);
    const manifest = (0, common_1.parseProjectManifest)(await reader.getProjectSchema()).asImpl;
    if (!(0, common_1.manifestIsV0_2_0)(manifest)) {
        throw new Error('Unsupported project manifest spec, only 0.2.0 is supported');
    }
    let ipfs;
    if (ipfsEndpoint) {
        ipfs = (0, ipfs_http_client_1.create)({ url: ipfsEndpoint });
    }
    const deployment = await replaceFileReferences(projectDir, manifest, authToken, ipfs);
    // Upload schema
    return uploadFile(deployment.toDeployment(), authToken, ipfs);
}
exports.uploadToIpfs = uploadToIpfs;
/* Recursively finds all FileReferences in an object and replaces the files with IPFS references */
async function replaceFileReferences(projectDir, input, authToken, ipfs) {
    if (Array.isArray(input)) {
        return (await Promise.all(input.map((val) => replaceFileReferences(projectDir, val, authToken, ipfs))));
    }
    else if (typeof input === 'object') {
        if (input instanceof Map) {
            input = mapToObject(input);
        }
        if (isFileReference(input)) {
            input.file = await uploadFile(fs_1.default.createReadStream(path_1.default.resolve(projectDir, input.file)), authToken, ipfs).then((cid) => `ipfs://${cid}`);
        }
        const keys = Object.keys(input);
        await Promise.all(keys.map(async (key) => {
            input[key] = await replaceFileReferences(projectDir, input[key], authToken, ipfs);
        }));
    }
    return input;
}
async function uploadFile(content, authToken, ipfs) {
    let ipfsClientCid;
    // if user provide ipfs, we will try to upload it to this gateway
    if (ipfs) {
        try {
            ipfsClientCid = (await ipfs.add(content, { pin: true, cidVersion: 0 })).cid.toString();
        }
        catch (e) {
            throw new Error(`Publish project to provided IPFS gateway failed, ${e}`);
        }
    }
    let ipfsClusterCid;
    try {
        ipfsClusterCid = await UploadFileByCluster(determineStringOrFsStream(content) ? await fs_1.default.promises.readFile(content.path, 'utf8') : content, authToken);
    }
    catch (e) {
        throw new Error(`Publish project to default cluster failed, ${e}`);
    }
    // Validate IPFS cid
    if (ipfsClientCid && ipfsClientCid !== ipfsClusterCid) {
        throw new Error(`Published and received IPFS cid not identical \n, 
    IPFS gateway: ${ipfsClientCid}, IPFS cluster: ${ipfsClusterCid}`);
    }
    return ipfsClusterCid;
}
exports.uploadFile = uploadFile;
function determineStringOrFsStream(toBeDetermined) {
    return !!toBeDetermined.path;
}
async function UploadFileByCluster(content, authToken) {
    var _a;
    const bodyFormData = new form_data_1.default();
    bodyFormData.append('data', content);
    const result = (await (0, axios_1.default)({
        headers: Object.assign({ Authorization: `Bearer ${authToken}`, 'Content-Type': 'multipart/form-data' }, bodyFormData.getHeaders()),
        method: 'post',
        url: constants_1.IPFS_CLUSTER_ENDPOINT,
        data: bodyFormData,
    })).data;
    return (_a = result.cid) === null || _a === void 0 ? void 0 : _a['/'];
}
function mapToObject(map) {
    // XXX can use Object.entries with newer versions of node.js
    const assetsObj = {};
    for (const key of map.keys()) {
        assetsObj[key] = map.get(key);
    }
    return assetsObj;
}
function isFileReference(value) {
    return value.file && typeof value.file === 'string';
}
//# sourceMappingURL=publish-controller.js.map