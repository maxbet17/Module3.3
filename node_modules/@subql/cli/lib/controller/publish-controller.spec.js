"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const child_process_1 = (0, tslib_1.__importDefault)(require("child_process"));
const fs_1 = (0, tslib_1.__importDefault)(require("fs"));
const os_1 = (0, tslib_1.__importDefault)(require("os"));
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const util_1 = require("util");
const common_1 = require("@subql/common");
const ipfs_http_client_1 = require("ipfs-http-client");
const rimraf_1 = (0, tslib_1.__importDefault)(require("rimraf"));
const build_1 = (0, tslib_1.__importDefault)(require("../commands/build"));
const codegen_1 = (0, tslib_1.__importDefault)(require("../commands/codegen"));
const types_1 = require("../types");
const init_controller_1 = require("./init-controller");
const publish_controller_1 = require("./publish-controller");
const projectSpecV0_0_1 = {
    name: 'mocked_starter',
    repository: '',
    endpoint: 'wss://rpc.polkadot.io/public-ws',
    author: 'jay',
    description: 'this is test for init controller',
    version: '',
    license: '',
};
const projectSpecV0_2_0 = {
    name: 'mocked_starter',
    repository: '',
    genesisHash: '0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3',
    endpoint: 'wss://rpc.polkadot.io/public-ws',
    author: 'jay',
    description: 'this is test for init controller',
    version: '',
    license: '',
};
const ipfsEndpoint = 'http://localhost:5001/api/v0';
//Replace your access token before test
const testAuth = 'MTA0MzE2NTc=JIwMq1cCzGIWddlskYRE';
jest.setTimeout(120000);
async function createTestProject(projectSpec) {
    const tmpdir = await fs_1.default.promises.mkdtemp(`${os_1.default.tmpdir()}${path_1.default.sep}`);
    const projectDir = path_1.default.join(tmpdir, projectSpec.name);
    const branch = (0, types_1.isProjectSpecV0_0_1)(projectSpec) ? 'v0.0.1' : 'v0.2.0';
    const projectPath = await (0, init_controller_1.cloneProjectGit)(tmpdir, projectSpec.name, 'https://github.com/subquery/subql-starter', branch);
    await (0, init_controller_1.prepare)(projectPath, projectSpec);
    // Install dependencies
    child_process_1.default.execSync(`npm i`, { cwd: projectDir });
    await codegen_1.default.run(['-l', projectDir]);
    await build_1.default.run(['-l', projectDir]);
    return projectDir;
}
describe('Cli publish', () => {
    let projectDir;
    afterEach(async () => {
        try {
            await (0, util_1.promisify)(rimraf_1.default)(projectDir);
        }
        catch (e) {
            console.warn('Failed to clean up tmp dir after test');
        }
    });
    it('should not allow uploading a v0.0.1 spec version project', async () => {
        projectDir = await createTestProject(projectSpecV0_0_1);
        await expect((0, publish_controller_1.uploadToIpfs)('', ipfsEndpoint, projectDir)).rejects.toBeDefined();
    });
    it(`upload file to ipfs`, async () => {
        // only enable when test locally
        const ipfs = (0, ipfs_http_client_1.create)({ url: ipfsEndpoint });
        //test string
        const cid = await (0, publish_controller_1.uploadFile)('Test for upload string to ipfs', testAuth);
        console.log(`upload file cid: ${cid}`);
        // test fs stream (project)
        projectDir = await createTestProject(projectSpecV0_2_0);
        const fsStream = fs_1.default.createReadStream(path_1.default.resolve(projectDir, 'project.yaml'));
        const cid2 = await (0, publish_controller_1.uploadFile)(fsStream, testAuth);
        console.log(`upload file cid: ${cid2}`);
    });
    it('should upload appropriate project to IPFS', async () => {
        projectDir = await createTestProject(projectSpecV0_2_0);
        const cid = await (0, publish_controller_1.uploadToIpfs)(projectDir, testAuth);
        expect(cid).toBeDefined();
        // validation no longer required, as it is deployment object been published
        // await expect(Validate.run(['-l', cid, '--ipfs', ipfsEndpoint])).resolves.toBe(undefined);
    });
    it('should not allow uploading a v0.0.1 spec version project', async () => {
        projectDir = await createTestProject(projectSpecV0_0_1);
        await expect((0, publish_controller_1.uploadToIpfs)('', ipfsEndpoint, projectDir)).rejects.toBeDefined();
    });
    it('throw error when v0.0.1 try to deploy', async () => {
        projectDir = await createTestProject(projectSpecV0_0_1);
        const reader = await common_1.ReaderFactory.create(projectDir);
        const manifest = (0, common_1.parseProjectManifest)(await reader.getProjectSchema()).asImpl;
        expect(() => manifest.toDeployment()).toThrowError('Manifest spec 0.0.1 is not support for deployment, please migrate to 0.2.0 or above');
    });
    it('convert to deployment and removed descriptive field', async () => {
        projectDir = await createTestProject(projectSpecV0_2_0);
        const reader = await common_1.ReaderFactory.create(projectDir);
        const manifest = (0, common_1.parseProjectManifest)(await reader.getProjectSchema()).asImpl;
        const deployment = manifest.toDeployment();
        expect(deployment).not.toContain('name');
        expect(deployment).not.toContain('author');
        expect(deployment).not.toContain('endpoint');
        expect(deployment).not.toContain('dictionary');
        expect(deployment).not.toContain('description');
        expect(deployment).not.toContain('repository');
        expect(deployment).toContain('genesisHash');
        expect(deployment).toContain('specVersion');
        expect(deployment).toContain('dataSources');
    });
});
//# sourceMappingURL=publish-controller.spec.js.map